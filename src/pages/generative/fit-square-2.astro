---
import G from "@lib/components/svg/builtin/G.astro";
import Rect from "@lib/components/svg/builtin/Rect.astro";
import Dots from "@lib/components/svg/shapes/patterns/dots.astro";
import type { NamedCssColor } from "@lib/components/svg/types";
import BaseLayout from "@lib/layouts/BaseLayout.astro";
import { range } from "@lib/util/iter";
import { chance, pick, rand } from "@lib/util/stokhos";

interface GridCell {
  index: { i: number; x: number; y: number };
  marked: boolean;
  width: number;
  height: number;
}

let [gridW, gridH] = [21, 9];
let size = gridW * gridH;

let widths = [1, 2, 3, 5];
let heights = [1, 2, 5];

function ratioOfConstantDiff(size: number, constant: number) {
  return (size - constant) / size;
}

function coordFromIndex(gridW: number, gridH: number) {
  return function (i: number) {
    return {
      x: i % gridW,
      y: Math.floor(i / gridW),
    };
  };
}

function cellFromCoord<T extends any[]>(buffer: T, gridW: number) {
  return function (i: number, offset = [0, 0]) {
    i += offset[0] + offset[1] * gridW;
    return buffer[i];
  };
}

function markArea(buffer: GridCell[], cell: GridCell, width: number, height: number) {
  let stop = false;

  for (let y = 0; y < height; y++) {
    if (stop) {
      break;
    }

    for (let x = 0; x < width; x++) {
      let sampleCell = cellFromCoord(buffer, gridW)(cell.index.i, [x, y]);

      if (sampleCell.marked) {
        width = x;

        if (chance(0.5)) {
          height = y + 1;
          stop = true;
        }

        break;
      }

      sampleCell.marked = true;
    }
  }

  cell.marked = true;
  cell.width = width;
  cell.height = height;
}

let vert_buffer = range<GridCell>(size, (i) => {
  let x = i % gridW;
  let y = Math.floor(i / gridW);

  return {
    index: { i, x, y },
    marked: false,
    width: 0,
    height: 0,
  };
});

for (let i = 0; i < vert_buffer.length; i++) {
  const cell = vert_buffer[i];

  if (cell.marked) {
    continue;
  }

  let { x, y } = coordFromIndex(gridW, gridH)(i);

  let mark_width = pick(widths);
  let mark_height = pick(heights);

  if (chance(0.9)) {
    mark_height = mark_width;
  }

  mark_width = Math.min(gridW - x, mark_width);
  mark_height = Math.min(gridH - y, mark_height);

  markArea(vert_buffer, cell, mark_width, mark_height);
}

const marked_buffer: (GridCell & { color: NamedCssColor; isSquare: boolean })[] = vert_buffer
  .filter((cell) => cell.width && cell.height)
  .map((cell) => {
    return {
      ...cell,
      color: pick<NamedCssColor[]>(["cadetblue", "yellowgreen", "darkslateblue"]),
      isSquare: cell.width == cell.height,
    };
  });

let frameSize = 512;

let cellWidth = frameSize / gridW;
let cellHeight = frameSize / gridH;

let m = Math.min(cellWidth, cellHeight);

cellWidth = m;
cellHeight = m;

let gridGap = 2.5;
let centerTranslate: [number, number] = [
  (-cellWidth * gridW) / 2 + gridGap,
  (-cellHeight * gridH) / 2 + gridGap,
];
---

<BaseLayout title="fit-rect-2" fullScreen={true}>
  <Dots id="dots" />
  <svg viewBox="-256 -256 512 512">
    <G translate={centerTranslate}>
      {
        marked_buffer.map(({ width, height, index: { x, y }, color, isSquare }) => {
          let translate: [number, number] = [x * cellWidth, y * cellHeight];

          [width, height] = [width * cellWidth, height * cellHeight];
          let scale: [number, number] = [
            ratioOfConstantDiff(width, gridGap),
            ratioOfConstantDiff(height, gridGap),
          ];

          let offsetRot = rand(-0.125, 0.125);
          let offsetTranslate = [rand(-0.25, 0.25), rand(-0.25, 0.25)];

          let fillOpacity = 0.35;
          let fill = "currentColor";
          let strokeOpacity = 0.45;
          if (isSquare && chance(0.5)) {
            fill = "url(#pattern-dots)";
            strokeOpacity = 0.15;
            fillOpacity = 0.65;
            color = "cadetblue";
          }

          return (
            <G {translate} {scale} {color}>
              <Rect
                rotate={offsetRot}
                translate={offsetTranslate}
                {width}
                {height}
                rx={pick([0.25, 0.5])}
                stroke="currentColor"
                stroke-opacity={strokeOpacity}
                {fill}
                fill-opacity={fillOpacity}
              />
            </G>
          );
        })
      }
    </G>
  </svg>
</BaseLayout>

<style>
  svg {
    width: 100%;
    height: 100%;
    overflow: visible;
  }

  svg rect {
    transition-property: fill-opacity;
    transition-duration: 165ms;
    transition-timing-function: ease;
    transition-delay: 75ms;
  }

  svg rect:hover {
    fill-opacity: 0.65;
    transition-duration: 125ms;
    transition-delay: 0ms;
  }
</style>
