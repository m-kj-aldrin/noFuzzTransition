---
import Circle from "@lib/components/svg/builtin/Circle.astro";
import G from "@lib/components/svg/builtin/G.astro";
import Path from "@lib/components/svg/builtin/Path.astro";
import Rect from "@lib/components/svg/builtin/Rect.astro";
import Dots from "@lib/components/svg/shapes/patterns/dots.astro";
import type { NamedCssColor } from "@lib/components/svg/types";
import BaseLayout from "@lib/layouts/BaseLayout.astro";
import { IF } from "@lib/util/comperator";
import { range } from "@lib/util/iter";
import { chance, pick, rand } from "@lib/util/stokhos";
import { fade } from "astro:transitions";

interface GridCell {
  index: { i: number; x: number; y: number };
  marked: boolean;
  width: number;
  height: number;
  requestedWidth: number;
  requestedHeight: number;
  xclip: boolean;
  yclip: boolean;
}

let [gridW, gridH] = [16, 24];
let size = gridW * gridH;

let widths = [1, 3, 13];
let heights = [1, 2];

function ratioOfConstantDiff(size: number, constant: number) {
  return (size - constant) / size;
}

function coordFromIndex(gridW: number, gridH: number) {
  return function (i: number) {
    return {
      x: i % gridW,
      y: Math.floor(i / gridW),
    };
  };
}

function cellFromCoord<T extends any[]>(buffer: T, gridW: number) {
  return function (i: number, offset = [0, 0]) {
    i += offset[0] + offset[1] * gridW;
    return buffer[i];
  };
}

function markArea(
  buffer: GridCell[],
  cell: GridCell,
  width: number,
  height: number,
) {
  let stop = false;
  // cell.requestedWidth = width;
  // cell.requestedHeight = height;

  // let xclip = false
  // let yclip = false

  for (let y = 0; y < height; y++) {
    if (stop) {
      break;
    }

    for (let x = 0; x < width; x++) {
      let sampleCell = cellFromCoord(buffer, gridW)(cell.index.i, [x, y]);

      if (sampleCell.marked) {
        width = x;

        if (chance(0.5)) {
          height = y + 1;
          stop = true;
        }

        break;
      }

      sampleCell.marked = true;
    }
  }

  if (width + cell.index.x == gridW) {
    cell.xclip = true;
  } else if (cell.index.x == 0) {
    cell.xclip = true;
  }
  cell.marked = true;
  cell.width = width;
  cell.height = height;
}

let vert_buffer = range<GridCell>(size, (i) => {
  let x = i % gridW;
  let y = Math.floor(i / gridW);

  return {
    index: { i, x, y },
    marked: false,
    width: 0,
    height: 0,
    requestedWidth: 0,
    requestedHeight: 0,
    xclip: false,
    yclip: false,
  };
});

for (let i = 0; i < vert_buffer.length; i++) {
  const cell = vert_buffer[i];

  if (cell.marked) {
    continue;
  }

  let { x, y } = coordFromIndex(gridW, gridH)(i);

  let mark_width = pick(widths);
  let mark_height = pick(heights);

  if (chance(0.9)) {
    mark_height = mark_width;
    // mark_height = 2
  }

  cell.requestedWidth = mark_width;
  cell.requestedHeight = mark_height;

  // let xclip = gridW - x < mark_width;
  // let yclip = gridH - y < mark_height;

  // cell.xclip = xclip;
  // cell.yclip = yclip;

  mark_width = Math.min(gridW - x, mark_width);
  mark_height = Math.min(gridH - y, mark_height);

  markArea(vert_buffer, cell, mark_width, mark_height);
}

const marked_buffer: (GridCell & {
  color: NamedCssColor;
  isSquare: boolean;
})[] = vert_buffer
  .filter((cell) => cell.width && cell.height)
  .map((cell, i) => {
    cell.index.i = i;
    return {
      ...cell,
      color: pick<NamedCssColor[]>([
        "cadetblue",
        "yellowgreen",
        "darkslateblue",
      ]),
      isSquare: cell.width == cell.height,
    };
  });

let frameSize = 512;

let cellWidth = frameSize / gridW;
let cellHeight = frameSize / gridH;

let m = Math.min(cellWidth, cellHeight);

cellWidth = m;
cellHeight = m;

let gridGap = 2.5;
let centerTranslate: [number, number] = [
  (-cellWidth * gridW) / 2 + gridGap,
  (-cellHeight * gridH) / 2 + gridGap,
];
---

<BaseLayout title="fit-rect-2" fullScreen={true}>
  <Dots id="dots" />
  <svg viewBox="-256 -256 512 512">
    <G scale={[1, 1]}>
      <G translate={centerTranslate}>
        {
          marked_buffer.map(
            ({
              width,
              height,
              index: { x, y, i },
              color,
              isSquare,
              requestedWidth,
              requestedHeight,
              xclip,
              yclip,
            }) => {
              y = gridH - y;
              y -= height;
              let translate: [number, number] = [x * cellWidth, y * cellHeight];
              let strokeOpacity = 0.45;

              let lines = false;
              if (isSquare && width > 2 && chance(0.75)) {
                lines = true;
                strokeOpacity = 0.05
              }

              [width, height] = [width * cellWidth, height * cellHeight];
              let scale: [number, number] = [
                ratioOfConstantDiff(width, gridGap),
                ratioOfConstantDiff(height, gridGap),
              ];
              let offsetRot = rand(-0.125, 0.125);
              let offsetTranslate = [rand(-0.25, 0.25), rand(-0.25, 0.25)];
              let fillOpacity = 0.35;
              let fill = lines ? "none" : "currentColor";

              if (isSquare && !lines && chance(0.5)) {
                fill = "url(#pattern-dots)";
                strokeOpacity = 0.15;
                fillOpacity = 0.65;
                color = "cadetblue";
              }
              return (
                <G {translate} {scale} {color}>
                  {xclip && (
                    <Rect
                      width={requestedWidth * cellWidth}
                      x={x == 0 ? -(requestedWidth * cellWidth - width) : null}
                      height={height}
                      fill="none"
                      stroke="currentColor"
                      stroke-dasharray={"4,1"}
                      stroke-opacity={strokeOpacity}
                    />
                  )}
                  <Rect
                    rotate={offsetRot}
                    translate={offsetTranslate}
                    {width}
                    {height}
                    rx={pick([0.25, 0.5])}
                    stroke="currentColor"
                    stroke-opacity={strokeOpacity}
                    {fill}
                    fill-opacity={fillOpacity}
                  />
                  {IF(lines, () => {
                    let cx = rand(0, width * (3 / 4));
                    let cy = rand(0, height * (3 / 4));
                    return (
                      <G>
                        <G fill={color} stroke-opacity={0.05}>
                          <Path
                            d={[
                              ["m", [0, 0]],
                              ["L", [cx, cy]],
                              ["L", [0, height]],
                              "z",
                            ]}
                            fill={chance(0.5) ? "none" : "currentColor"}
                            fill-opacity={pick([0.04, 0.03, 0.08])}
                          />
                          <Path
                            d={[
                              ["m", [width, 0]],
                              ["L", [cx, cy]],
                              ["L", [0, 0]],
                              "z",
                            ]}
                            fill={chance(0.5) ? "none" : "currentColor"}
                            fill-opacity={pick([0.04, 0.03, 0.08])}
                          />
                          <Path
                            d={[
                              ["m", [width, height]],
                              ["L", [cx, cy]],
                              ["L", [width, 0]],
                              "z",
                            ]}
                            fill={chance(0.5) ? "none" : "currentColor"}
                            fill-opacity={pick([0.04, 0.03, 0.08])}
                          />
                          <Path
                            d={[
                              ["m", [0, height]],
                              ["L", [cx, cy]],
                              ["L", [width, height]],
                              "z",
                            ]}
                            fill={chance(0.5) ? "none" : "currentColor"}
                            fill-opacity={pick([0.04, 0.03, 0.08])}
                          />
                        </G>
                        <Circle {cx} {cy} r={1} fill-opacity={0.05} />
                      </G>
                    );
                  })}
                </G>
              );
            },
          )
        }
      </G>
    </G>
  </svg>
</BaseLayout>

<style>
  svg {
    width: 100%;
    height: 100%;
    overflow: visible;
  }

  svg rect {
    transition-property: fill-opacity;
    transition-duration: 165ms;
    transition-timing-function: ease;
    transition-delay: 75ms;
  }

  svg rect:hover {
    fill-opacity: 0.65;
    transition-duration: 125ms;
    transition-delay: 0ms;
  }
</style>
